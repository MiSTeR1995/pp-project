// функции сервисы обычно хранятся в отдельных файлах



// сделаем взаимодействие с сервером отдельной функцией
// функция занимается тем, что настраивает запрос.
// она фетчит(посылает запрос на сервер), получает какой-то ответ от сервера
// после этого трансформирует этот ответ в json
// внутри этой функции асинхронный код и это нужно учесть
// т.к. код пойдет выполняться дальше, не ожидая ответа от сервера (где фетч)
// из-за этого функция может вернуть ошибку, а не нужный нам результат
// для этого нужно указать, что функция имеет асинхронный код.
// async поможет это сделать (ES8)
// после этого уже можно использовать его парный оператор await (всегда вместе)
// он ставится перед теми операцими, которые нам необходимо дождаться

const postData = async (url, data) => {
    // внутри переменной лежит промис, который возвращает фетч
    // нам нужно дождаться выполнение фетча, поэтому ставим await
    // неважно какой результат, но выполнения мы должны дождаться
    // код не совсем синхронный, он не блокирует выполение кода дальше
    // но именно для этого будет ждать до 30 сек(по стандарту) ответа
    const result = await fetch(url, {
        method: 'POST',
        // для json нужно использовать заголовки
        headers: {
            'Content-type': 'application/json'
        },
        body: data
    });

    // вернем результат в формате json
    // здесь тоже понадобится await, т.к. возващается промис
    // эта операция возникает и проводится не сразу, мы не знаем
    // какой там большой объект json и сколько нужно времени на обработку
    return await result.json();
};


async function getResource (url) {

    const result = await fetch(url);

    // т.к. фетч не реагирует на ошибки 404 500 и тд, то такое поведение
    // нужно сделать самим

    // два свойства у промимса, которые есть у промиса, вернувшегося с фетч
    // .ok - что-то получили, все окей
    // .status  - попадаем на тот статус, который вернулся от сервера

    // если пошло что-то не так, то выкидываем ошибку
    // есл выкидывается ошибка в ручном режиме, то срабатывает catch
    if (!result.ok) {
        // объект ошибки. throw - выкидывает ошибку в консоль
        throw new Error(`Could not fetch ${url}, status: ${result.status}`);
    }
    return await result.json();
}

export {postData};
export {getResource};
